---
title: "Clean codes"
output: pdf_document
---
---
title: ""
author: "Anita Hessami Pilehrood, Isabelle Liu, Christian Hardat"
subtitle: "STA302 - Fall 2023 - Project"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: pdf_document
---

```{r, include=FALSE}
# Load necessary libraries
library(readr)
library(dplyr)
library(ggplot2)
packageurl <- "https://cran.r-project.org/src/contrib/Archive/pbkrtest/pbkrtest_0.4-4.tar.gz" 
install.packages(packageurl, repos=NULL, type="source")
install.packages("car", dependencies=TRUE)
library(car)
install.packages("psych")
library(psych)
install.packages("MASS")
library(MASS)
install.packages("leaps")
library(leaps)
```

```{r}
# Read the dataset
data <- read.csv("STA302 Part 3 Cleaned Dataset.csv")

# Convert categorical variables to factors
data$Status_name <- as.factor(data$Status_name)

# Create dummy variables for categorical predictors
data <- model.matrix(~ . - 1, data = data)
data <- data.frame(data)

# Define the model formula
model_formula <- Thinness ~ Hepatitis_B + Measles + Healthcare_Expenditure + Schooling + Status_nameDeveloping

# Fit the linear model to the entire dataset
model <- lm(model_formula, data = data)

# Summary of the model
summary(model)


```

```{r}
#### log(Thinness) transformation #1
data$Log_Thinness <- log(data$Thinness + 1) # Adding 1 to avoid log(0)

# Fit the model with the transformed response variable
model_transformed <- lm(Log_Thinness ~ Hepatitis_B + Measles + Healthcare_Expenditure + Schooling + Status_nameDeveloping, data = data)

# Check the new residuals vs. fitted values plot
plot(fitted(model_transformed), resid(model_transformed),
     xlab = "Fitted Values", ylab = "Residuals",
     main = "Residuals vs. Fitted Values after Log Transformation")
abline(h = 0, col = "red", lty = 2)

elog_hat <- resid(model_transformed)
# Normal QQ plot
qqnorm(elog_hat)
qqline(elog_hat)
```


```{r}
model1 <- lm(Thinness ~ Hepatitis_B + Measles + Healthcare_Expenditure + Status_nameDeveloping + Schooling, data = new_clean)
model1
```

```{r}
# Find fitted and residual values of original model
y_hat <- fitted(model1)
e_hat <- resid(model1)


```

```{r}
# Check condition 1 and condition 2
length(y_hat)
length(new_clean$Thinness)
plot(x = y_hat  , y = new_clean$Thinness[1:length(y_hat)]   , main="Response vs Fitted",
     xlab="Fitted", ylab="Thinness")
abline(a = 0, b = 1, lty=2)

```

There is no single identifiable pattern so it is randomly scattered. 

```{r, eval=F}
pairs(new_clean[, c(1:4, 6,7)])
```



```{r}
plot(x = y_hat, y = e_hat, main="Residual vs Fitted", xlab="Fitted",
     ylab="Residuals")
plot(e_hat ~ new_clean$Hepatitis_B, main="Residuals vs Hepatitis B", xlab="Hepatitis B", ylab="Residual")
plot(e_hat ~ new_clean$Measles, main="Residuals vs Measles", xlab="Measles", ylab="Residual")
plot(e_hat ~ new_clean$Healthcare_Expenditure, main="Residuals vs Healthcare Expenditure", xlab="Healthcare Expenditure", ylab="Residual")
boxplot(e_hat ~ new_clean$Status_nameDeveloping, main="Residuals vs Status Name", xlab="Status Name", ylab="Residual")
plot(e_hat ~ new_clean$Schooling, main="Residuals vs Schooling", xlab="Schooling", ylab="Residual")
qqnorm(e_hat)
qqline(e_hat)
plot(x = y_hat, y = model1$Thinness, main="Response vs Fitted",
     xlab="Fitted", ylab="Thinness")
abline(a = 0, b = 1, lty=2)
hist(new_clean$Thinness, main="Histogram", xlab="Thinness")


```



```{r}

boxCox(model1)

any(Dataset$Measles <= 0)
constant_value <- 0.0001
Dataset$adjMeasles <- Dataset$Measles + constant_value
p <- powerTransform(Dataset$adjMeasles)
summary(p)

new_clean$crootThinness <- (new_clean$Thinness)^(1/3)
constant_value <- 0.0001
new_clean$adjMeasles <- new_clean$Measles + constant_value
new_clean$lnMeasles <- log(new_clean$adjMeasles+1)
model3 <- lm(crootThinness ~ Hepatitis_B + lnMeasles + Healthcare_Expenditure + Status_nameDeveloping + Schooling, data = new_clean)
model3

hist(new_clean$crootThinness, main="Histogram", xlab="sqrt(Thinness)")
y_hat <- fitted(model3)
e_hat <- resid(model3)
plot(x = y_hat, y = e_hat, main="Residual vs Fitted", xlab="Fitted",
     ylab="Residuals")
plot(e_hat ~ new_clean$Hepatitis_B, main="Residuals vs Hepatitis B", xlab="Hepatitis B", ylab="Residual")
plot(e_hat ~ new_clean$lnMeasles, main="Residuals vs ln(Measles)", xlab="Measles", ylab="Residual")
plot(e_hat ~ new_clean$Healthcare_Expenditure, main="Residuals vs Healthcare Expenditure", xlab="Healthcare Expenditure", ylab="Residual")
boxplot(e_hat ~ new_clean$Status_nameDeveloping, main="Residuals vs Status Name", xlab="Status Name", ylab="Residual")
plot(e_hat ~ new_clean$Schooling, main="Residuals vs Schooling", xlab="Schooling", ylab="Residual")
qqnorm(e_hat)
qqline(e_hat)
plot(x = y_hat, y = model3$crootThinness, main="Response vs Fitted",
     xlab="Fitted", ylab="croot(Thinness)")
abline(a = 0, b = 1, lty=2)
```



```{r}
model3 <- lm(crootThinness ~ Hepatitis_B + lnMeasles + Healthcare_Expenditure + Status_nameDeveloping + Schooling, data = new_clean)
model3

```

```{r}
# Defining the cutoffs
# useful values:
n <- nrow(new_clean)
p <- length(coef(model3))-1

# leverage cutoff
h_cut <- 2*(p+1)/n 

# cooks cutoff
D_cut <- qf(0.5, p+1, n-p-1) 

# DFFITS cutoff
fits_cut <- 2*sqrt((p+1)/n)

# DFBETAS cutoff
beta_cut <- 2/sqrt(n)

#Compute the measures for each problematic observation on transformed model
# leverage
h_ii <- hatvalues(model3) 

# outlier
r_i <- rstandard(model3) 

# Cook's Distance
D_i <- cooks.distance(model3) 

# DFFITS
dffits_i <- dffits(model3)

# DFBETAS
dfbetas_i <- dfbetas(model3)

```

```{r}
# identify leverage points
which(h_ii > h_cut)
```

```{r}
# identify outliers
which(r_i > 4 | r_i < -4)
```

```{r}
# influential on all fitted values
which(D_i > D_cut)
```

```{r}
# influential on own fitted value
which(abs(dffits_i) > fits_cut)
```

```{r}
# influential on a coefficient
for(i in 1:6){
        print(paste0("Beta ", i-1))
        print(which(abs(dfbetas_i) > beta_cut))
}
```


```{r}
nrow(new_clean)

# Split data in half
s <- sample(1:nrow(new_clean), 1285 , replace=F) 
train <- new_clean[s ,]
test <- new_clean[-s,]
```

```{r}
install.packages("psych")
library(psych)
describe(train)
describe(test)
```

```{r}
# Fit final model 

final <- lm(crootThinness ~ lnMeasles + Healthcare_Expenditure + Status_nameDeveloping + Schooling, data = train ) 

# check conditions
pairs(train[,c(4,6,7,10 )])
plot(train$crootThinness ~ fitted(final))
```

```{r}
# Check assumptions
par(mfrow=c(3,2))
plot(resid(final)~fitted(final), xlab="fitted", ylab="residuals") 
for(i in c(4,6,7,10)){
        plot(resid(final) ~ train[,i], xlab=names(train)[i], ylab="residuals")
}
qqnorm(resid(final))
qqline(resid(final))
```

```{r}
# Multicollinearity
vif(final)
```

```{r}
# a function that will compute problematic observations for you
probobs <- function(model, data){ 
        n_1 <- nrow(data)
        p <- length(coef(model))-1
# leverage cutoff
        h_cut <- 2*(p+1)/n
        print(which(hatvalues(model) > h_cut))
# outliers
        print("outliers (large)")
        print(which(rstandard(model) > 4 | rstandard(model) < -4)) 
# cooks cutoff
        D_cut <- qf(0.5, p+1, n-p-1)
        print("Cooks")
        print(which(cooks.distance(model) > D_cut))
# DFFITS cutoff
        fits_cut <- 2*sqrt((p+1)/n)
        print("DFFITS")
        print(which(abs(dffits(model)) > fits_cut))
# DFBETAS cutoff
        beta_cut <- 2/sqrt(n)
        for(i in 1:(p+1)){
                print(paste0("Beta ", i-1))
                print(which(abs(dfbetas(model)[,i]) > beta_cut)) 
                }
}
# to use the function, run above and this next line:
probobs(final, train)
```

```{r}
summary(final)
```

```{r}
# Fit final model using test dataset 

final_test <- lm(crootThinness  ~ lnMeasles + Healthcare_Expenditure +
                    Status_nameDeveloping + Schooling, data = test ) 
summary(final_test)
```

```{r}
# check conditions for test
pairs(test[,c(4,6,7,10 )])
plot(test$crootThinness ~ fitted(final_test))
```

```{r}
# check assumptions
par(mfrow=c(3,2))
plot(resid(final_test)~fitted(final_test), xlab="fitted", ylab="residuals") 
for(i in c(4,6,7,10)){
        plot(resid(final_test) ~ test[,i], xlab=names(test)[i], ylab="residuals") 
}

qqnorm(resid(final_test)) 
qqline(resid(final_test))

#multicollinearity
vif(final_test)
```

```{r}
# problematic observations
# to use the function, run this next line (since function was already run earlier): 
probobs(final_test, test)
```
